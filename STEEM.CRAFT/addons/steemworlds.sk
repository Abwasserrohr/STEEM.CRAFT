#
# ==============
# steemworlds.sk v0.0.26
# ==============
# steemworlds.sk is part of the STEEM.CRAFT addons.
# ==============
# > Steemworlds allows the player to store his steemworld to the
# > Steem Blockchain. Steemworlds are a flat world by default to
# > not create not necessary data.
# ==============

#
# > Important Note:
# > steemworlds.sk is still not fully ready to use. While saving and loading worlds works, the
# > methods may change which could break already stored worlds later on. Once steemworlds.sk
# > reaches it's version to v1.0.0, the saving will either not be changed anymore or there will
# > be backwards compatibility for versions after v1.0.0. Until then, use it with care and store
# > backups on your side. Saving 4 chunks will cost at least 6 million rc.

#
# > Steemworld comments, which hold data which refers to the world
# > on the Steem Blockchain, can be altered in various ways. Do not
# > change these by yourself if you don't want to create your own
# > world network which doesn't connect to other servers.
options:
  #
  # > The post prefix changes how the comment looks like on blog based Steem apps.
  # > This could get changed in the future to link to a world explorer.
  postprefix: <a href=""https://steemit.com/@steem.craft""><img src=""https://cdn.steemitimages.com/DQmUzWn7xJhLpPhGAczEpkcph4gNMrRdcCeTC5RVHnRQrjE/steemheader-left.png""></a>
  #
  # > The json id is used to identify STEEM.CRAFT world transactions.
  jsonidplots: STEEM.CRAFT/worlds
  #
  # The app is used to know which app is responsible for the comments.
  commentapp: STEEM.CRAFT
  #
  # > The format is used to detect the format of the comment.
  commentformat: markdown
  #
  # > The tags can be used to query specific contents from the blockchain.
  commenttags: ["steemcraft","steemworlds"]
  #
  # > The title is used on almost all Steem based blog apps to see what
  # > the comment is about.
  commenttitle: "World - <world>"
  #
  # > The maximum length of json transactions may change. It is currently
  # > set at a maximum length of 2000. To prevent exeeding this, it is
  # > set at 1800 to prevent any problems by too long custom json.
  customjsonlength: 1800
  #
  # > The time until a transaction is timed out and repeated in ticks.
  timeoutticks: 800
  #
  # > The comment parent author is the author of the comments which hold
  # > all the worlds. If this is changed, all already saved worlds can't
  # > be loaded anymore.
  commentparentauthor: steem.craft
  #
  # > The commennt parent permlink works the same way the parent author works.
  # > If this is changed, you can't load worlds from other comment parent permlinks.
  commentparentpermlink: w
  
on load:
  delete {sc::accountload}

import:
  java.io.File
  java.nio.file.Files
  java.util.regex.Pattern
  org.apache.commons.io.FileUtils
  com.fasterxml.jackson.databind.ObjectMapper
  com.fasterxml.jackson.databind.node.ArrayNode
  com.fasterxml.jackson.databind.node.ObjectNode
  org.bukkit.Bukkit
  org.bukkit.WorldCreator
  org.bukkit.World$Environment
  org.bukkit.WorldType
  org.bukkit.event.world.WorldInitEvent
  org.bukkit.GameRule
  com.boydti.fawe.object.schematic.Schematic
  com.sk89q.worldedit.regions.CuboidRegion
  com.sk89q.worldedit.bukkit.BukkitWorld
  com.sk89q.worldedit.extent.clipboard.io.ClipboardFormat
  com.sk89q.worldedit.extent.clipboard.io.ClipboardFormats
  com.sk89q.worldedit.EditSession
  com.sk89q.worldedit.world.World
  com.sk89q.worldedit.math.BlockVector3
  java.util.HashMap
  java.util.ArrayList
  java.lang.Integer
  eu.bittrade.libs.steemj.base.models.operations.CustomJsonOperation
  eu.bittrade.libs.steemj.base.models.AccountName
  eu.bittrade.libs.steemj.SteemJ
  eu.bittrade.libs.steemj.base.models.Permlink
  eu.bittrade.libs.steemj.base.models.operations.CommentOperation
  org.bukkit.block.Biome

#
# > Command - /steemworldbiome | /swbiome, /scbiome
# > Actions:
# > Sets the biome of the steem world for the player, if it is
# > owned by the player.
command /steemworldbiome [<text="PLAINS">]:
  aliases: /swbiome, /scbiome
  trigger:
    set {_steemaccount} to getSyncedAccount(player)
    if "%player's world%" does not contain "steemworlds-%{_steemaccount}%":
      message "%getChatPrefix()% You can only change the size of your worlds."
      stop
    setSteemWorldBiome(player's world, arg-1)

#
# > Command - /steemworldsize | /swsize, /scsize
# > Actions:
# > Sets the size of the steem world for the player, if it is
# > owned by the player.
command /steemworldsize [<text>]:
  aliases: /swsize, /scsize
  trigger:
    set {_steemaccount} to getSyncedAccount(player)
    if "%player's world%" does not contain "steemworlds-%{_steemaccount}%":
      message "%getChatPrefix()% You can only change the size of your worlds."
      stop

    #
    # > Use a text as a argument to allow custom feedback messages
    # > instead of the predefined ones by Skript.
    set {_size} to arg-1 parsed as number

    #
    # > If the input was no text, send a custom message which
    # > sends how the command should be used.
    if {_size} is not a number:
      message "%getChatPrefix()% /swsize <number>"
      stop

    #
    # > Don't allow a size smaller than 1.
    if {_size} < 1:
      stop

    setSteemWorldSize(player's world,round({_size}))

#
# > Command - /steemworldsize | /swsize, /scsize
# > Actions:
# > Sets the size of the steem world for the player, if it is 
# > owned by the player.
command /steemspawn:
  aliases: /swspawn, /scspawn
  trigger:
    set {_steemaccount} to getSyncedAccount(player)
    if "%player's world%" does not contain "steemworlds-%{_steemaccount}%":
      message "%getChatPrefix()% You can only change the spawn of your worlds."
      stop

    setSteemWorldSpawn(player's world,player's location)
    message "%getChatPrefix()% The spawn of this world has been changed."

#
# > Command - /steemworldsave | /swsave, /scsave, /sws
# > Actions:
# > Saves the world of the player, if it is a steemworld of the player.
command /steemworldsave:
  aliases: /swsave, /scsave, /sws
  trigger:
    set {_steemaccount} to getSyncedAccount(player)
    if "%player's world%" does not contain "steemworlds-%{_steemaccount}%":
      message "%getChatPrefix()% You can only save your own world."
      stop
    $ thread
    saveSteemWorld(player)

#
# > Command - /steemworldload | /swload, /scload, /swl
# > Actions:
# > Loads the world of the player, if it is a steemworld of the player.
command /steemworldload [<number=0>]:
  aliases: /swload, /scload, /swl
  trigger:
    #
    # > To show off that saving and loading works, there is a single world per
    # > user, which is hardcoded for now. It is always named "steemworlds-steemusername-worldname"
    if "%player's world%" contains "steemworlds-":
      set {_world} to "%player's world%"
      replace all "steemworlds-" with "" in {_world}
      set {_account} to getGeneralStorageData("steemworlds",{_world},"steemaccount")
      #
      # > The following process needs to be executed as a thread, a global variable
      # > is used to call the function.
      while {sc::accountload} is set:
        wait 2 ticks
      set {sc::accountload} to {_account}
      $ thread
      loadSteemWorld({sc::accountload},"%player's world%",player,arg-1)

#
# > Command - /visit | /steemworldvisit | /swvisit | /scvisit | /swv
# > Actions:
# > Visits a steem user and loads the world. Currently, there are no checks
# > involved if there is actually a world saved. 
command /visit [<text>] [<text=home>]:
  aliases: /steemworldvisit, /swvisit, /scvisit, /swv
  trigger:
    delete {_created}
    delete {_world}
    #
    # > Convert the Steem account name to a Steem supported format.
    set {_steemaccount} to arg-1
    set {_steemaccount} to {_steemaccount}.toLowerCase()

    #
    # > Convert the world name to a Steem supported format.
    set {_worldname} to arg-2
    set {_worldname} to {_worldname}.toLowerCase()
    set {_worldname} to normalize({_worldname})

    #
    # > Maybe, the server aleady loaded this world once, this allows to bypass
    # > any checks for existing worlds.
    set {_created} to getGeneralStorageData("steemworlds","%{_steemaccount}%-%{_worldname}%","created")

    if {_created} is true:
      set {_world} to "%{_steemaccount}%-%{_worldname}%"

    else:
      #
      # > Check if the account exists.
      getAccount({_steemaccount})

      #
      # > Wait for a response which happens in a thread.
      while getAccountResponse({_steemaccount}) is "wait":
        wait 1 tick

      #
      # > To also support entering the ingame username, this part will
      # > convert the ingame username to the steem account name.
      if getAccountResponse({_steemaccount}) is not set:
        set {_steemaccount} to getSyncedAccount({_steemaccount} parsed as offline player)
        #
        # > Check this again for existance.
        getAccount({_steemaccount})
	
        #
        # > Wait again for the response.
        while getAccountResponse({_steemaccount}) is "wait":
          wait 1 tick

      #
      # > Only create a world, if the steem account exists.
      if getAccountResponse({_steemaccount}) is set:

        set {_permlink} to "re-steemcraft-steemworlds-%{_steemaccount}%-%{_worldname}%"

        #
        # > Check if the world exists on Steem.
        getSteemContent({_steemaccount},{_permlink})

        #
        # > Wait until the Steem content response is no longer "wait".
        while getSteemContentResponse({_steemaccount},{_permlink}) is "wait":
          wait 1 tick

        #
        # > Get the Steem content response.
        set {_c} to getSteemContentResponse({_steemaccount},{_permlink})

        set {_world} to "%{_steemaccount}%-%{_worldname}%"
        set {_author} to {_c}.getAuthor().getName().toString()

        #
        # > If the author is not set, this means that this world doesn't
        # > exist on Steem, if the player wants to visit his own, not existing
        # > world, then create it, others will get a error.
        if {_author} is "":
          if getSyncedAccount(player) is not {_steemaccount}:
            if getGeneralStorageData("steemworlds",{_world},"created") is not true:
              message "%getChatPrefix()% %{_worldname}% by %{_steemaccount}% does not exist."
              stop
          else:
            if getGeneralStorageData("steemworlds",{_world},"created") is not true:
              message "%getChatPrefix()% Creating %{_worldname}% now..."

    #
    # > Only create and save general storage information, if the world is not loaded.
    if "steemworlds-%{_world}%" parsed as world is not set:
      createSteemWorld("%{_world}%")
      saveGeneralStorageData("steemworlds",{_world},"steemaccount",{_steemaccount})

    #
    # > The createsteemworld is currently not async. But the dependency
    # > FastAsyncWorldEdit allows doing it. This will be added soon to
    # > remove any lag from visiting worlds.
    while metadata value "steemworlds-%{_world}%" of getDummy() is "wait":
      wait 1 tick

    #
    # > Teleport the player after the world has been created.
    set {_world} to "steemworlds-%{_world}%" parsed as world
    set {_location} to getSteemWorldSpawn({_world})
    if {_location} is set:
      teleport player to {_location}
    else:
      teleport player to spawn of {_world}

#
# > Function - saveSteemWorld:
# > Saves the world of the player.
# > Parameters:
# > <player>the player who wants to save the own world.
function saveSteemWorld(player:player):
  #
  # > Only save the world if the player is online.
  if {_player} is online:
    #
    # > Get the steem account of the player. Since the server
    # > will broadcast transactions, the steem account needs 
    # > to be synced with the server.
    set {_steemname} to getSyncedAccount({_player})
    if {_steemname} is false:
      message "%getChatPrefix()% You have to sync your account first:" to {_player}
      message "%getChatPrefix()% /steemconnect <steem username>" to {_player}
      stop

    #
    # > Get the account in a thread to validate.
    getAccount("%{_steemname}%",false)
    
    wait 1 tick

    #
    # > Set the response to a local usable variable.
    set {_account} to getAccountResponse("%{_steemname}%")

    #
    # > Check if the account is valid and usable for broadcasting.
    if validateSyncedSteemAccountUUID({_player},{_account}) is false:
      message "%getChatPrefix()% Your Steem account UUID doesn't match with yours." to {_player}
      message "%getChatPrefix()% /steemconnect <steem username>" to {_player}
      stop
    if validateSyncedSteemAccountAuths({_player},{_account}) is false:
      message "%getChatPrefix()% The server has no authorisation to broadcast transactions for you." to {_player}
      message "%getChatPrefix()% /steemconnect <steem username>" to {_player}
      stop

    set {_world} to {_player}'s world

    #
    # > Get the size of the world to set the correct world coordinates.
    set {_wb} to {_world}.getWorldBorder()
    set {_size} to {_wb}.getSize() / 32
	
    #
    # > Calculate both x- and z-start and endcoordinates of the world.
    set {_xstart} to (0 - ({_size} * 16)) + 1
    set {_zstart} to (0 - ({_size} * 16)) + 1
    set {_xend} to ({_size} * 16) - 1
    set {_zend} to ({_size} * 16) - 1
	
    #
    # > Loop through the coordinates and add all chunks of the world
    # > to a list.
    set {_x} to {_xstart}
    while {_xdone} is not set:
      delete {_zdone}
      set {_z} to {_zstart}
      while {_zdone} is not set:
        add chunk at location {_x}, 0, {_z} in {_world} to {_chunks::*}
        add 16 to {_z}
        if {_z} > {_zend}:
          set {_zdone} to true
      add 16 to {_x}
      if {_x} > {_xend}:
        set {_xdone} to true

    #
    # > Tell the player that the process is working and how long it may take. 
    # > It is estimated that every chunk takes at least 10 seconds to process.
    message "%getChatPrefix()% Your world is now being saved. This will take at least %(size of {_chunks::*} * 10) + 70% seconds." to {_player}

    #
    # > The bossbar is perfect to represent a loading bar, use it here.
    set {_bossbar} to createBossBar("&lSaving world...","yellow","10")
    set {_progress} to 0.0
    {_bossbar}.setProgress({_progress})
    {_bossbar}.addPlayer({_player})
    {_bossbar}.setVisible(true)

    #
    # > Since getting the block number of a transaction is currenttly not working for me,
    # > the start block number is saved here. This is used to query the history of the account
    # > and check only transactions that have been broadcasted after this block number.
    set {_startHeadBlockNumber} to getHeadBlockNumber()

    #
    # > Set the plot size to allow the progress percentage later.
    set {_plotsize} to size of {_chunks::*}
    set {_pdone} to 100 / {_plotsize}

    # 
    # > Load the world data using loadSteemWorldData.
    set {_map} to loadSteemWorldData({_steemname},"%{_world}%",null,0)

    #
    # > The returned HashMap contains the response and the world. We need the
    # > world to check if there is a chunk that is already stored on the
    # > Steem blockchain, which we do not need to broadcast again.
    set {_worlddata} to {_map}.get("world")
    set {_response} to {_map}.get("response")

    #
    # > Create a new ArrayNode which is used to add all necessary blocks of
    # > the world to the final world comment.
    set {_objectMapper} to new ObjectMapper()
    set {_arraynode} to {_objectMapper}.createArrayNode()
	
    #
    # > All chunks are now looped. A schematic file is created and splitted
    # > into usable parts and encoded with base64.
    loop {_chunks::*}:
      delete {_chunksplit::*}
      add 1 to {_loopnumber}

      set {_x1} to x-coord of loop-value.getBlock(0,0,0)
      set {_x2} to x-coord of loop-value.getBlock(15,255,15)
      set {_z1} to z-coord of loop-value.getBlock(0,0,0)
      set {_z2} to z-coord of loop-value.getBlock(15,255,15)

      #
      # > The schematic files are stored in the "tmp" folder in the root folder of the
      # > Minecraft server.
      set {_file} to new File("tmp/steemworlds_%{_world}%_%loop-value.getX()%_%loop-value.getZ()%.schem")
      set {_chunkx} to loop-value.getX()
      set {_chunkz} to loop-value.getZ()

      #
      # > WorldEdit is maybe unsure how it should place the blocks if it is
      # > exactly on 0.5, that's why 0.5 is deducted on x- and z-coords.
      # > This is also done in the loading process to match this.
      set {_b} to BlockVector3.at({_x1}-0.5, 0, {_z1}-0.5)
      set {_t} to BlockVector3.at({_x2}-0.5, 255, {_z2}-0.5)

      set {_bworld} to new BukkitWorld({_world})
      set {_reg} to new CuboidRegion({_bworld}, {_b}, {_t})
      set {_schem} to new Schematic({_reg})
	  
      #
      # > Usually, ClipboardFormat.SPONGE_SCHEMATIC! schould be used,
      # > but since this generates currently an error, a alternative
      # > is used.
      #set {_format} to ClipboardFormat.SPONGE_SCHEMATIC!
      set {_format} to ClipboardFormats.findByAlias("schem")

      {_schem}.save({_file},{_format})

      while {_file}.exists() is false:
        wait 1 tick

      set {_bytes} to Files.readAllBytes({_file}.toPath())

      #
      # > Delete the temporary created file again, since it was only
      # > needed to get the bytes from it.
      {_file}.delete()

      #
      # > The bytes of the schematic file now get converted to a base64 encoded string.
      set {_base64} to BytesToBase64({_bytes})

      #
      # > Since a simple base64 encoded string could be compressed further, it
      # > will be compressed with gzip and then again returned with base64.
      # > Since schematic files hold some data, it will be always worth it.
      set {_string} to compressBase64({_base64})

      #
      # > If the base64 encoded string matches with the already stored one, skip
      # > broadcasting new transactions for this chunk and broadcast the already
      # > stored block to the new comment.
      if {_string} is {_worlddata}.get("%{_chunkx}%|%{_chunkz}%"):
		
        #
        # > Reading the json metadata of the content is done using ObjectMapper.
        set {_jsonNode} to {_objectMapper}.readTree({_response}.getJsonMetadata())

        #
        # > Get the compressed and base64 encoded string of the duplicate chunk.
        set {_plot} to {_jsonNode}.get("world").textValue()

        #
        # > Decompress and decode the base64 string.
        set {_plot} to decompressBase64({_plot})

        #
        # > Since we now have a string, it can be loaded using jackson.
        set {_plot} to {_objectMapper}.readTree({_plot})

        #
        # > Get all the block numbers for the duplicate chunk.
        loop {_plot}.size().longValue() times:
          set {_plotpart} to {_plot}.get(loop-number - 1)
          #
          # > Store the block numbers of the duplicate chunk.
          set {_chunkpart} to {_objectMapper}.createObjectNode()
          {_chunkpart}.put("x", {_plotpart}.get("x"))
          {_chunkpart}.put("z", {_plotpart}.get("z"))
          {_chunkpart}.put("i", {_plotpart}.get("i"))
          {_chunkpart}.put("b", {_plotpart}.get("b").textValue())
          {_arraynode}.add({_chunkpart})

      #
      # > If the chunk is not exactly the same, broadcast it again.
      else:
        #
        # > Here, the compressed base64 encoded string is split into multiple, usable strings.
        while {_done} is not set:
          if length of {_string} > {@customjsonlength}:
            add the first {@customjsonlength} character of {_string} to {_chunksplit::*}
            set {_string} to {_string}.replaceFirst(Pattern.quote(the first {@customjsonlength} character of {_string}), "")
          else:
            add {_string} to {_chunksplit::*}
            set {_done} to true
        delete {_done}
        delete {_partid}
        set {_shortworld} to "%{_world}%"

        #
        # > Only the short world name is necessary here.
        replace "steemworlds-" with "" in {_shortworld}

        #
        # > Now, the splitted chunks are being looped through. Every splitted chunk
        # > gets a custom json transaction, which is currently set by simply settings
        # > a string.
        loop {_chunksplit::*}:
          add 1 to {_partid}
          set {_txcontent} to "{""w"":""%{_shortworld}%"",""x"":%{_chunkx}%,""z"":%{_chunkz}%,""s"":%size of {_chunksplit::*}%,""i"":%{_partid}%,""data"":""%{_chunksplit::%{_partid}%}%""}"

          #
          # > Now, the custom json is broadcasted. The saving process will repeat the
          # > process in case of any error.
          while {_done} is not set:
            set {_txuuid} to getRandomUUID()
            customJsonOperation({_txuuid},{_steemname},"{@jsonidplots}",{_txcontent})
		  
            #
            # > Reset the timeout timer.
            delete {_waittime}

            while getSteemResponse({_txuuid}) is "wait":
              #
              # > Add 1 to the timeout timer, if it goes above 800, set the
              # > repsonse to an error to repeat.
              add 1 to {_waittime}
              if {_waittime} > {@timeoutticks}:
                set metadata value "steem-tx-response-%{_txuuid}%" of getDummy() to "error"

              wait 1 tick

            if getSteemResponse({_txuuid}) is "done":
              set {_done} to true

            #
		    # > If there has been a error, wait 1 second and repeat.
            else:
              message "%getChatPrefix()% Error. Repeating." to {_player}
              wait 1 second

          delete {_done}

          #
          # > If there are still some splits to go, wait 3 seconds after one has been done.
          if size of {_chunksplit::*} >= {_partid}:
            wait 3 seconds
      #
      # > Tell the player about the current status of the world broadcasting.
      {_bossbar}.setTitle("&lBroadcasting chunks...")
      set {_progress} to (({_loopnumber} * {_pdone})/100)/2
      {_bossbar}.setProgress({_progress})

    #
    # > Tell the player that the world has been saved and that it needs to wait
    # > until the transactions are consensus, since I currently can't get the block
    # > number of the transaction directly.
    set {_timer} to 80
    loop 80 times:
      add 0.005 to {_progress}
      {_bossbar}.setTitle("&lWait &6&l%{_timer}%&f&l seconds...")
      {_bossbar}.setProgress({_progress})
      remove 1 from {_timer}
      wait 1 second

    #
    # > Tell the player that the world is now being broadcasted.
    {_bossbar}.setTitle("&lBroadcasting world...")

    #
    # > Go through the last 1000 transactions of the user.
    set {_history} to getAccountHistory({_steemname},-1,1000)

    #
    # > Loop the transactions and find transactions that
    # > happened since beginning of this process and filter
    # > the needed block numbers out.
    loop ...{_history}.keySet():
      set {_h} to {_history}.get(loop-value)
      if {_h}.getBlock() >= {_startHeadBlockNumber}:
        if try {_h}.getOp().getJson() is set:
          set {_json} to "%{_h}.getOp().getJson()%"
          if {_json} contains """w"":""%{_shortworld}%":
            set {_objectMapper} to new ObjectMapper()
            set {_jsonNode} to {_objectMapper}.readTree({_json})
            set {_x} to {_jsonNode}.get("x")
            set {_z} to {_jsonNode}.get("z")
            set {_i} to {_jsonNode}.get("i")

            #
            # > Store the block numbers within the comment custom json.
            set {_chunkpart} to {_objectMapper}.createObjectNode()
            {_chunkpart}.put("x", {_x})
            {_chunkpart}.put("z", {_z})
            {_chunkpart}.put("i", {_i})
            {_chunkpart}.put("b", "%{_h}.getBlock()%")
            {_arraynode}.add({_chunkpart})

    #
    # > Once the chunk block numbers have been collected, 
    # > add other custom json data to the json.
    set {_finaljson} to {_objectMapper}.createObjectNode()
    {_finaljson}.put("app", "{@commentapp}")

    #
    # > Apply tags by converting the array to a list and
    # > adding each entry into the ArrayNode.
    set {_tags} to {_objectMapper}.createArrayNode()
    set {_tags::*} to ...{@commenttags}
    loop {_tags::*}:
      {_tags}.add(loop-value)

    {_finaljson}.put("tags", {_tags})
    {_finaljson}.put("format", "{@commentformat}")

    #
    # > The world size is important to set the world size correctly on load.
    {_finaljson}.put("wsize", {_size})

    #
    # > Set the spawn location to the string from the local storage.
    set {_spawn} to getGeneralStorageData("steemworlds",{_shortworld},"spawn")
    if {_spawn} is set:
      {_finaljson}.put("spawn", {_spawn})

    #
    # > Get the biome from the local storage and add it to the json.
    set {_biome} to getGeneralStorageData("steemworlds",{_shortworld},"biome")
    if {_biome} is set:
      {_finaljson}.put("biome", {_biome})

    #
    # > To shrink down the reference parts, this data is being compressed and encoded into base64.
    {_finaljson}.put("world", compressBase64({_arraynode}.toString()))

    set {_txid} to "%{_world}%"
    set {_txuuid} to "%{_txid}.toLowerCase()%"
    set {_comment} to "{@postprefix}"
    set {_title} to {@commenttitle}
    replace all "<world>" with "%{_world}%" in {_title}	

    #
    # > The createComment function is going to create a comment.
    createComment({_txuuid},{_steemname},{_comment},"{@commentparentauthor}","{@commentparentpermlink}",{@commenttags},{_title},{_finaljson}.toString())

    #
    # > The comment is going to be created in a separate thread, to catch
    # > if everything worked, we can wait here until the response is no longer
    # > "wait".
    while getSteemResponse({_txuuid}) is "wait":
      wait 1 tick

    if getSteemResponse({_txuuid}) is "done":
      message "%getChatPrefix()% Your world has been saved sucessfully." to {_player}
      #
      # > Set the loading bossbar to 100% and the title to a success message
      # > to tell the player that everything worked.
      {_bossbar}.setTitle("&lWorld sucessfully saved.")
      {_bossbar}.setProgress(1.0)
    else:
      message "%getChatPrefix()% A error occured." to {_player}
      message "%getChatPrefix()% %getSteemResponse({_txuuid})%" to {_player}

    #
    # > Remove the bossbar after one second.
    wait 1 second

    #
    # > Remove all players from the bossbar to no longer display it
    # > to the players, only deleting it is not enough.
    {_bossbar}.removeAll()
    delete {_bossbar}

#
# > Function - loadSteemWorld:
# > Loads the speficied world.
# > Parameters:
# > <text> The steem username of the account which should be loaded.
# > <text> The permlink of the world which should be loaded.
# > <player> The player who should get informed about status messages.
function loadSteemWorld(steemname:text,worldname:text,player:player,blockid:number=0):
  #
  # > The function has been called with a global variable. Delete it here
  # > to allow more calls of this function after it has been called.
  delete {sc::accountload}

  #
  # > The steem name is needed, check if it is actually set.
  if {_steemname} is set:
    set {_steemname} to {_steemname}.toLowerCase()
    #
    # > Get the world parsed as a world.
    set {_world} to "%{_worldname}%" parsed as world
    set {_txid} to "%{_world}%"
    set {_shortworld} to {_txid}
    replace "steemworlds-" with "" in {_shortworld}

    #
    # > Tell the player that the world is now being loaded.
    message "%getChatPrefix()% Loading %{_steemname}%'s world..." to {_player}

    #
    # > The bossbar is perfect to represent a loading bar, use it here.
    set {_bossbar} to createBossBar("&lLoading world...","yellow","10")
    set {_progress} to 0.0
    {_bossbar}.setProgress({_progress})
    {_bossbar}.addPlayer({_player})
    {_bossbar}.setVisible(true)

    # 
    # > Load the world data using loadSteemWorldData. By adding the bossbar
    # > variable, the player gets informed about the loading progress.
    set {_map} to loadSteemWorldData({_steemname},{_worldname},{_bossbar},{_blockid})

    #
    # > The returned HashMap contains the response and the world. We need the
    # > world.
    set {_worlddata} to {_map}.get("world")

    #
    # > Get the size of the plotparts to give the player a loading bar.
    set {_worlddataparts::*} to ...{_worlddata}.keySet()
    set {_plotsize} to size of {_worlddataparts::*}
    set {_pdone} to 100 / {_plotsize}

    loop {_worlddataparts::*}:

      #
      # > Decompress the big chunk data, save it to file and load it.
      set {_loop-value} to loop-value
      set {_chunkcoord::*} to {_loop-value} split at "|"

      #
      # > The chunk coordinates are needed to load the chunks at the right
      # > place.
      set {_x} to "%{_chunkcoord::1}%" parsed as integer
      set {_z} to "%{_chunkcoord::2}%" parsed as integer
	  
      #
      # > Decompress and save the data to a schematic file to allow other programs
      # > to load and insert it into the world of the server.
      set {_body} to decompressBase64({_worlddata}.get({_loop-value}))
      set {_newbytes} to Base64ToBytes({_body})
      set {_file} to new File("tmp/%{_txid}%_%{_x}%_%{_z}%.schem")
      FileUtils.writeByteArrayToFile({_file}, {_newbytes})

      #
      # > To place the chunk, a vector needs to be created, which has to be at the
      # > 0-spot if the chunks. Get this point and create a usable vector.
      set {_block} to {_world}.getChunkAt({_x},{_z}).getBlock(0,0,0)
      set {_l} to location of {_block}
      set {_x} to x-coord of {_l}
      set {_z} to z-coord of {_l}

      #
      # > Deduct 0.5 from each vector to prevent incorrect rounding within
      # > WorldEdit which can corrupt worlds.
      set {_vector} to BlockVector3.at({_x}-0.5, 0, {_z}-0.5)

      #
      # > WorldEdit needs a BukkitWorld instead of a CraftWorld to work.
      set {_bworld} to new BukkitWorld("%{_worldname}%" parsed as world)
	  
      #
      # > Load the chunk schematic into the clipboard.
      set {_clipboard} to ClipboardFormats.findByFile({_file})

      #
      # > Load the chunk from the clipboard and create a schematic.
      set {_schematic} to {_clipboard}.load({_file})

      #
      # > Delete the loaded schematic now, since it is no longer needed.
      {_file}.delete()

      #
      # > Tell the player about the current pasting status.
      add 1 to {_partnumber}
      {_bossbar}.setTitle("&lPasting chunks... [%{_pdone} * {_partnumber}%%%]")
      set {_progress} to 0.75+(({_partnumber} * {_pdone})/100)/4
      {_bossbar}.setProgress({_progress})

      #
      # > Paste the schematic with the chunk to the world at the speficied vector.
      set {_session} to {_schematic}.paste({_bworld}, {_vector})

    #
    # > Tell the player that the loading process has been done successfully.
    message "%getChatPrefix()% Successfully loaded %{_steemname}%'s world." to {_player}
    {_bossbar}.setTitle("&lLoad successful.")

    #
    # > Remove the bossbar after one second.
    wait 1 second

	#
    # > Remove all players from the bossbar to no longer display it
    # > to the players, only deleting it is not enough.
    {_bossbar}.removeAll()
    delete {_bossbar}

    #
    # > Apply world settings to the loaded world.
    set {_biome} to getGeneralStorageData("steemworlds",{_shortworld},"biome")
    set {_size} to getGeneralStorageData("steemworlds",{_shortworld},"size")
    setSteemWorldBiome({_world},{_biome})
    setSteemWorldSize({_world},round({_size}))

#
# > Function - loadSteemWorldData
# > Loads a steem based world.
# > Parameters:
# > <text> steem name
# > <text> world name
# > [<BossBar>] a Bukkit bossbar to update the current progress
# > Returns:
# > <Hashmap>["response",SteemJ response],["world",<HashMap>["chunkid","base64 string"]]
function loadSteemWorldData(steemname:text,worldname:text,bossbar:object,blockid:number=0) :: object:
  #
  # > Set the permlink to allow getting the comment content.
  set {_permlink} to "re-steemcraft-%{_worldname}%"

  #
  # > Load the content using getSteemContent without thread,
  # > since we're already in a thread.
  getSteemContent({_steemname},{_permlink},false,{_blockid})
	
  #
  # > Create a HashMap which stores all the data.
  set {_map} to new HashMap()

  #
  # > Get the Steem content response.
  while {_c} is not set:
    set {_c} to getSteemContentResponse({_steemname},{_permlink})
  {_map}.put("response",{_c})

  #
  # > Reading the json metadata of the content is done using ObjectMapper.
  set {_objectMapper} to new ObjectMapper()    
  set {_jsonNode} to {_objectMapper}.readTree({_c}.getJsonMetadata())

  #
  # > Get the compressed and base64 encoded string.
  set {_plot} to {_jsonNode}.get("world").textValue()

  #
  # > The shortworld is used for short storage names.
  set {_shortworld} to {_worldname}
  replace "steemworlds-" with "" in {_shortworld}

  #
  # > Get the serialized location and save it to the storage.
  set {_spawn} to {_jsonNode}.get("spawn").textValue()
  saveGeneralStorageData("steemworlds",{_shortworld},"spawn",{_spawn})

  #
  # > Get the biome and store it.
  set {_biome} to {_jsonNode}.get("biome").textValue()
  saveGeneralStorageData("steemworlds",{_shortworld},"biome",{_biome})

  #
  # > Set the world size to the defined size in the Steem comment.
  set {_size} to {_jsonNode}.get("wsize").doubleValue()
  saveGeneralStorageData("steemworlds",{_shortworld},"size",{_size})

  set {_size} to {_size}*32
  set {_wb} to {_world}.getWorldBorder()
  {_wb}.setWarningDistance(0)
  {_wb}.setSize({_size})

  #
  # > Decompress and decode the base64 string, this increases the size.
  set {_plot} to decompressBase64({_plot})

  #
  # > Since we now have a string, it has to be loaded using jackson again,
  # > to access it later.
  set {_plot} to {_objectMapper}.readTree({_plot})

  #
  # > Get all the block numers to load the chunks.
  loop {_plot}.size().longValue() times:
    set {_plotpart} to {_plot}.get(loop-number - 1)
    set {_x} to {_plotpart}.get("x")
    set {_z} to {_plotpart}.get("z")
    set {_i} to {_plotpart}.get("i")
    set {_b} to {_plotpart}.get("b").textValue()

    set {_plotparts::%{_x}%|%{_z}%|%{_i}%} to {_b} parsed as number
    add 1 to {_plotpartamount::%{_x}%|%{_z}%}

  #
  # > Get the size of the plotparts to give the player a loading bar.
  set {_plotsize} to size of {_plotparts::*}
  set {_pdone} to 100 / {_plotsize}

  #
  # > A empty ArrayList is needed for comparaisons later.
  set {_emptylist} to new ArrayList()

  #
  # > Loop through the parts of the world and gather the needed
  # > informations.
  loop {_plotparts::*}:
    add 1 to {_partnumber}

    #
    # > Get the operations of a block.
    set {_ops} to getOpsInBlock(loop-value,false)

    loop {_ops}.size() times:
      set {_tx} to loop-number - 1
      #
      # > Only go forward if the operation contains json.
      if {_ops}.get({_tx}).getOp() is instance of CustomJsonOperation:
        #
        # > Only go forward of the required posting auths match with the requested steem username.
        set {_auths} to try {_ops}.get({_tx}).getOp().getRequiredPostingAuths()
        if {_auths} is not {_emptylist}:
          if {_ops}.get({_tx}).getOp().getRequiredPostingAuths().get(0).getName() is {_steemname}:
            if {_bossbar} is not null:
              #
              # > Tell the player how the loading process is doing.
              {_bossbar}.setTitle("&lLoading... [%{_partnumber} * {_pdone}%%%]")
              set {_progress} to (({_partnumber} * {_pdone})/100)/1.5
              {_bossbar}.setProgress({_progress})
            #
            # > Get the json Metadata as a string and check if the world matches with the
            # > world which should be loaded.
            set {_json} to "%{_ops}.get({_tx}).getOp().getJson()%"
            if {_json} contains """w"":""%{_shortworld}%":
              set {_objectMapper} to new ObjectMapper()
              set {_jsonNode} to {_objectMapper}.readTree({_json})
              set {_x} to {_jsonNode}.get("x")
              set {_z} to {_jsonNode}.get("z")
              set {_i} to {_jsonNode}.get("i")
              set {_data} to {_jsonNode}.get("data").textValue()

              set {_plotparts::%{_x}%|%{_z}%|%{_i}%} to {_data}

  if {_bossbar} is not null:
    #
    # > Tell the player about the current status.
    {_bossbar}.setTitle("&lDecompressing world...")
    set {_progress} to 0.5
    {_bossbar}.setProgress({_progress})

  #
  # > Set some variables to calculate the percentage of a loaded world.
  set {_partnumber} to 0
  set {_plotsize} to size of {_plotpartamount::*}
  set {_pdone} to 100 / {_plotsize}

  #
  # > Create a HashMap which contains the world data.
  set {_finalparts} to new HashMap()

  #
  # > Set the chunk parts together to one big chunk.
  loop {_plotpartamount::*}:
    set {_data} to ""
    loop loop-value times:
      set {_data} to "%{_data}%%{_plotparts::%loop-index-1%|%loop-number%}%"
    {_finalparts}.put(loop-index,{_data})

  {_map}.put("world",{_finalparts})

  delete {_finalparts}
  return {_map}

#
# > Function - getSteemWorldRevisions
# > Gets all revisions for the defined steem username and world name.
# > Parameters:
# > <text>steem username
# > <text>Steemworld name
# > Retuns:
# > <HashMap>[blockid,json metadata]
function getSteemWorldRevisions(steemname:text,worldname:text) :: object:
  set {_account} to new AccountName({_steemname})
  set {_SteemJ} to new SteemJ()

  #
  # > Create a permlink and get the world which should be stored there.
  set {_searchedpermlink} to "re-steemcraft-%{_worldname}%"

  set {_result} to {_steemj}.getContent({_account},new Permlink({_searchedpermlink}))

  #
  # > Get the creation date of the comment to stop searching for more
  # > revisions once the creation date has been reached.
  set {_creationdate} to {_result}.getCreated().getDateTimeAsInt()

  set {_start} to -1
  
  #
  # > This HashMap will hold all reversions of the world.
  set {_revisions} to new HashMap()
  
  #
  # > We can get a maximum of 1000 transactions at a time.
  set {_limit} to 1000
  
  #
  # > Loop until the first creation post has been found.
  while {_done} is not set:
    #
    # > Get the history of the account from Steem.
    set {_history} to {_SteemJ}.getAccountHistory({_account},{_start},{_limit})

    #
    # > Get the keys of the HashMap and convert them into a Skript list to loop.	
    loop ...{_history}.keySet():
      #
      # > The steem based worlds are stored in comments, look out for CommentOperation.
      if {_history}.get(loop-value).getOp() is a instance of CommentOperation:
        #
        # > Not any comment that has been made is interesting for us, just go further if
        # > the permlink matches with the seachred one.
        if {_history}.get(loop-value).getOp().getPermlink().getLink() is {_searchedpermlink}:
          #
          # > Add the block number and metadata of this world to the revisions HashMap.
          {_revisions}.put({_history}.get(loop-value).getBlock().intValue(),{_history}.get(loop-value).getOp().getJsonMetadata())

          #
          # > If this transaction has reached or somehow even exceeded the creation date of the
          # > first world save, stop here, since there will be no more revisions before the 
          # > first creation (save) of the world.
          if {_creationdate} >= {_history}.get(loop-value).getTimestamp().getDateTimeAsInt():
            set {_done} to true

      #
      # > Warning: This is an explaination of how getAccountHistory can be used to
      # > loop through all transactions from an account, if you know it already,
      # > there is no reason to read it.
      # > If we get the account history, every transaction will have an number which
      # > will increase each time a new trasnsaction is made by the account, to search
      # > through the account, we first started with -1, which gives us the latest
      # > 1000 transactions of the account. To get the next 1000, we have to get the last
      # > transaction number, here loop-value and decrease it by our limit, here 1000.
      # > Since SteemJ wants Integers and Skript is not always trustworthy 
      # > for the creation of new integers, Integer.valueOf() is used.
      # > -------------------------------------------------------------------------------
      # > Example: I have 20000 transactions in my account.
      # > {_SteemJ}.getAccountHistory(new AccountName("Exampleuser"),-1,1000)
      # > This will show the latest 1000 transactions by Exampleuser.
      # > The returned HashMap has keys according to the transaction number of the user:
      # > [20000,19999,19998,19997] and so on.
      # > After Skript is done with looping, just take the last used value, 20000 in
      # > our case and remove 1000 from it. If we remove 1000 from 20000, we have 19000.
      # > Then, we can repeat the process until we have everything we searched for.
      # > {_SteemJ}.getAccountHistory(new AccountName("Exampleuser"),19000,1000)
      # > You see, we just take the last used key of the loop, remove 1000 (limit) and
      # > call it again. Be sure to use integers in getAccountHistory.
      # > -------------------------------------------------------------------------------
      if {_lowestkey} is not set:
        set {_lowestkey} to "%loop-value%" parsed as integer
      else if "%loop-value%" parsed as integer is smaller than {_lowestkey}:
        set {_lowestkey} to "%loop-value%" parsed as integer

    set {_start} to Integer.valueOf({_lowestkey})	  
  return {_revisions}

#
# > Function - createSteemWorld
# > Creates or loads a steemworld for the defined name.
# > Parameters:
# > <text>Steemworld name
function createSteemWorld(name:text):
  #
  # > Sets the steemworlds metadata value to wait to allow other
  # > commands and functions to wait until the world is ready.
  set metadata value "steemworlds-%{_name}%" of getDummy() to "wait"
  saveGeneralStorageData("steemworlds",{_name},"created",true)

  #
  # > To create a new world, the WorldCreator is very useful,
  # > it allows to set the world type, environment, and generator
  # > settings before actually creating it.
  set {_world} to new WorldCreator("steemworlds-%{_name}%")
  {_world}.environment(Environment.NORMAL!)
  {_world}.type(WorldType.FLAT!)

  #
  # > Disable any villages from spawning in.
  {_world}.generateStructures(false)

  #
  # > Remove any not necessary block layers from the world to reduce size.
  {_world}.generatorSettings("{""biome"":""minecraft:plains"",""layers"":[{""block"":""minecraft:grass_block"",""height"":1}],structures:{""village"":{}}}")

  #
  # > The world is created after all settings from the WorldCreator have
  # > been done.
  set {_world} to Bukkit.createWorld({_world})

  #
  # > The created world needs some changes to prevent resource intensive.
  {_world}.setSpawnFlags(false,false)
  {_world}.setMonsterSpawnLimit(0)
  {_world}.setAnimalSpawnLimit(0)
  {_world}.setSpawnLocation(0, 4, 0)

  #
  # > The size of the world is limited to a fixed size for now.
  # > This is needed to prevent players from creating too much
  # > world. Only the world within the border is being saved
  # > to the Steem Blockchain.
  set {_wb} to {_world}.getWorldBorder()
  {_wb}.setCenter(spawn of {_world})
  {_wb}.setWarningDistance(0)
  {_wb}.setSize(32)

  #
  # > Once the "wait" value from the steemworlds metadatahas been deleted,
  # > other commands and functions can go forward as the world is now
  # > successfully loaded.
  delete metadata value "steemworlds-%{_name}%" of getDummy()

#
# > Function - setSteemWorldSize
# > Sets the world border of the world to the defined size.
# > The size is multiplied by 32.
# > Parameters:
# > <world>the steem world which should be changed
# > <number>the new size of the world, 1 = 32x32 size.
function setSteemWorldSize(world:world,size:number):
  set {_wb} to {_world}.getWorldBorder()
  {_wb}.setCenter(spawn of {_world})
  {_wb}.setWarningDistance(0)
  {_wb}.setSize({_size}*32)

#
# > Function - setSteemWorldSpawn
# > Sets a new spawn for the defined steemworld.
# > Parameters:
# > <world>the steem world which should be changed
# > <location>the new spawn location of the world
function setSteemWorldSpawn(world:world,l:location):
  set {_world} to "%{_world}%"
  replace all "steemworlds-" with "" in {_world}
  set {_l} to serializelocation({_l})
  saveGeneralStorageData("steemworlds",{_world},"spawn",{_l})

#
# > Function - getSteemWorldSpawn
# > Gets the spawn for the defined steemworld from storage.
# > Parameters:
# > <world>the steem world which should be changed
function getSteemWorldSpawn(world:world) :: location:
  set {_worldstring} to "%{_world}%"
  replace all "steemworlds-" with "" in {_worldstring}
  set {_l} to getGeneralStorageData("steemworlds",{_worldstring},"spawn")
  set {_l} to deserializelocation({_l},{_world})
  return {_l}

#
# > Function - setSteemWorldBiome
# > Sets the biome of the defined steem world to the
# > biome name.
# > Parameters:
# > <world>the steem world which should be changed
# > <text>the name of the biome to which the world should be changed
function setSteemWorldBiome(world:world,biome:text):
  #
  # > Convert our string to a biome.
  set {_biome} to Biome.valueOf({_biome}.toUpperCase())

  #
  # > If the result of the convert is a biome, go forward.
  if {_biome} is instance of a Biome:

    #
    # > Save the changed biome to the storage.
    set {_name} to "%{_world}%"
    replace all "steemworlds-" with "" in {_name}
    saveGeneralStorageData("steemworlds",{_name},"biome", "%{_biome}%")

    #
    # > Only the world within the world border has to be changed, get
    # > the worldborder to know what has to be changed.
    set {_wb} to {_world}.getWorldBorder()

    #
    # > Add 4 extra blocks to prevent transitions within the border.
    set {_size} to "%{_wb}.getSize()+4%" parsed as number

    #
    # > Start from the lowest point and loop through until all
    # > world parts have been changed to the new biome type.
    set {_xstart} to (0 - {_size}) / 2
    set {_zstart} to (0 - {_size}) / 2
    loop {_size} times:
      set {_z} to {_zstart}
      loop {_size} times:
        {_world}.setBiome(Integer.valueOf({_xstart}), Integer.valueOf({_z}), {_biome}) 
        add 1 to {_z}
        #
        # > Take a short break after each 50 changes.
        add 1 to {_i}
        if {_i} > 50:
          wait 1 tick
          delete {_i}
      add 1 to {_xstart}

    #
    # > Refresh all loaded chunks from this world to display the new biomes.
    set {_chunks::*} to ...{_world}.getLoadedChunks()
    set {_craftworld} to {_world}.getHandle().getWorld()
    loop {_chunks::*}:
      {_craftworld}.refreshChunk(loop-value.getX(), loop-value.getZ())

#
# > Function - setSteemWorldGamerule
# > Changes the gamerule of the world to the specified setting.
# > Parameters:
# > <world>the world
# > <text>the vanilla gamerule name which should be changed
# > <setting>the value to which the gamerule should be changed
function setSteemWorldGamerule(world:world,gamerule:text,setting:object):
  set {_gamerule} to GameRule.getByName({_gamerule})
  {_world}.setGameRule({_gamerule},{_setting})

#
# > Function - getSteemWorldGamerule
# > Returns the gamerule value of the world.
# > Parameters:
# > <world>the world
# > <text>the vanilla gamerule name of which the set value should be returned
function getSteemWorldGamerule(world:world,gamerule:text) :: object:
  set {_gamerule} to GameRule.getByName({_gamerule})
  return {_world}.getGameRuleValue({_gamerule})

#
# > Event - on WorldInitEvent
# > Triggered once a world is initialized
# > Actions:
# > This event will set the KeepSpawnInMemory value of
# > all initialized worlds to false to prevent lagspikes.
on WorldInitEvent with priority HIGHEST:
  if "%event.getWorld()%" contains "steemworlds-":
    event.getWorld().setKeepSpawnInMemory(false)
